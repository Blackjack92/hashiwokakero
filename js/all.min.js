
class Chip {
    
    constructor(value, x, y, mark_function) {
        this.value = value;
        this.x = x;
        this.y = y;
        this.mark_function = mark_function;
		
		this.id = x + "_" + y;
        this.marked = false;
		this.highlighted = false;
    }
	
	toggle_mark() {
		if (this.marked) {
			this.unmark();
		} else {
			this.mark();
		}
	}
	
	mark() {
		this.marked = true;
		$("#" + this.id).css("background-color", "green");
	}
	
	unmark() {
		this.marked = false;
		$("#" + this.id).css("background-color", "transparent");
	}
	
	toogle_highlight() {
		this.unmark();
		
		if (this.highlighted) {
			this.unhighlight();
		} else {
			this.highlight();
		}
	}
	
	highlight() {	
		$("#" + this.id).css("background-color", "orange");
		this.highlighted = true;
	}
	
	unhighlight() {
		$("#" + this.id).css("background-color", "transparent");
		this.highlighted = false;
	}
	
	create_visualization() {
		var btn = document.createElement("button");
        btn.className = "mc";
		btn.id = this.id;
		
        var ref = this;
        btn.onclick = function(){
            ref.mark_function(ref);
        };
		
		btn.oncontextmenu = function(ev) {
			ev.preventDefault();
			ref.toogle_highlight();
			return false;
		}
        
        var t = document.createElement("span");
        t.className = 'mc-' + this.value;
        btn.appendChild(t);
        return btn;
	}
}

class Connection {
    
    constructor(first, second, count) {
        this.first = first;
        this.second = second;  
		this.count = count;
		
		this.update_start_end(first, second);
    }
	
	update_start_end(first, second) {
		if (first.x === second.x) {
            this.direction = "ve";
            this.x_start = first.x;
            this.x_end = first.x;
            this.y_start = Math.min(first.y, second.y) + 1;
            this.y_end = Math.max(first.y, second.y) - 1;
        } 
        else {
            this.direction = "ho";
            this.x_start = Math.min(first.x, second.x) + 1;
            this.x_end = Math.max(first.x, second.x) - 1;
            this.y_start = first.y;
            this.y_end = first.y;
        }
	}
	
	intersect_point(x, y) {
		return this.x_start <= x && this.x_end >= x && this.y_start <= y && this.y_end >= y;
	}
	
	get_fields() {
		var fields = [];
		for (var i = this.x_start; i <= this.x_end; i++) {
			for (var j = this.y_start; j <= this.y_end; j++) {
				fields.push(i + " " + j);
			}
		}
		return fields;
	}
	
	intersect_fields(fields, other_fields) {
		for (var i = 0; i < fields.length; i++) {
			var field = fields[i];
			for (var j = 0; j < other_fields.length; j++) {
				var other_field = other_fields[j];
				if (field === other_field) {
					return true;
				}
			}
		}
		return false;
	}
	
    intersect_connection(other) {
		var fields = this.get_fields();
		var other_fields = other.get_fields();
		
		return this.intersect_fields(fields, other_fields) || this.intersect_fields(other_fields, fields);
    }
	
	does_connect(first, second) {
        return (this.first === first && this.second === second) || (this.first === second && this.second == first);
    }
	
	create_visualization() {
		var span = document.createElement("span");
		span.className = "co-" + this.direction + "-" + this.count;
		return span;
	}
}

class Game {
    
    constructor() {
        this.x_size = 5;
        this.y_size = 5;
        
        this.chips = [];
		this.connections = [];
    }

    init_by_json(json) {
		var csv = "3 - 4 - - 2 - 2 - 2 - - 2 \n\
- - - - 3 - 3 - 2 - - 2 - \n\
- - - - - - - 1 - - 2 - - \n\
1 - 5 - 7 - 6 - - 1 - - 2 \n\
- - - - - - - 1 - - 3 - - \n\
1 - 6 - 4 - 7 - - 3 - - 1 \n\
- - - - - - - - 1 - - 1 - \n\
2 - 6 - 6 - 6 - - - 5 - 2 \n\
- 1 - - - - - - - 1 - - - \n\
2 - - - 4 - 7 - 4 - 4 - 2 \n\
- - 1 - - - - - - - - - - \n\
- 2 - - 3 - 5 - 4 - - 1 - \n\
2 - - 2 - 2 - 2 - - 2 - 2";
		var data = Papa.parse(csv, {delimiter: " "});
		console.log(data);
		
		var ref = this;
		var mark_function = function(chip) { return ref.marking(chip) };

		for (var row = 0; row < data.data.length; row++) {
			for (var col = 0; col < data.data[row].length; col++) {
				var entry = data.data[row][col];
				if (entry === '-') {
					continue;
				}
				
				this.chips.push(new Chip(parseInt(entry), col, row, mark_function));
			}
		}
		
		this.x_size = data.data[0].length;
        this.y_size = data.data.length;
		
		$("div.game").empty();
		var game_gui = $("div.game")[0];
		game_gui.appendChild(this.create_visualization());
    }
	
	marking (chip) {
		var marked_chips = this.chips.filter(function (item) { return item.marked });
		
		// mark a single chip
		if (marked_chips.length <= 0 || (marked_chips.length == 1 && marked_chips.indexOf(chip) >= 0)) {
			chip.toggle_mark();			
		} else {
			// mark second chip and connect them if possible
			var first = marked_chips[0];
			
			// check if they are horizontal or vertical the same
			if (first.x != chip.x && first.y != chip.y) { return; }

			// check if the connection already exists, three possiblities:
			// - does not exist: create new connection
			// - single connection does exist: add second connection
			// - double connection does exist: remove connection
			var connection = this.connections.find(function(item) { return item.does_connect(first, chip) });
			
			if (connection !== undefined) {
				// single connection exist: add second connection
				if (connection.count === 1) {
					connection.count += 1;
					this.draw_connection(connection);                        
				} 
				// double connection exist: remove connection 
				else {
					this.remove_connection(connection);
					var index = this.connections.indexOf(connection);
					if (index > -1) { this.connections.splice(index, 1); }
				}
				first.unmark();
				
			} else {
				// create new connection
				connection = new Connection(first, chip, 1);
				
				// check connection intersects with another connection
				var intersect = this.connections.some(function(item) { return connection.intersect_connection(item) });
				if (intersect) { return; }
			
				// check connections intersects with another chip
				intersect = this.chips.some(function(item) { return item !== first && item !== chip && connection.intersect_point(item.x, item.y) });
				if (intersect) { return; }
				
				// connection does not intersect, so add it
				this.connections.push(connection);
				this.draw_connection(connection);
				first.unmark();
			}
		}
	}
	
    init() {
		var ref = this;
        var mark_function = function(chip) { return ref.marking(chip) };
			
		// default game
        this.chips[0] = new Chip(2, 0, 0, mark_function);
        this.chips[1] = new Chip(2, 4, 0, mark_function);
        this.chips[2] = new Chip(3, 0, 2, mark_function);
        this.chips[3] = new Chip(5, 2, 2, mark_function);
        this.chips[4] = new Chip(4, 4, 2, mark_function);
        this.chips[5] = new Chip(2, 0, 4, mark_function);
        this.chips[6] = new Chip(4, 2, 4, mark_function);
		
		$("div.game").empty();
		var game_gui = $("div.game")[0];
		game_gui.appendChild(this.create_visualization());
    }

	draw_connection(connection) {
		 for (var i = connection.x_start; i <= connection.x_end; i++) {
			for (var j = connection.y_start; j <= connection.y_end; j++) {
				var cell = "r-" + j + "_c-" + i;
				$( "#" + cell).html(connection.create_visualization());
			}
		}
	}
	
    remove_connection(connection) {
        for (var i = connection.x_start; i <= connection.x_end; i++) {
            for (var j = connection.y_start; j <= connection.y_end; j++) {
                var cell = "r-" + j + "_c-" + i;
                var span = document.createElement("span");
                span.className = 'empty';
                $( "#" + cell).html(span);
            }
        }
    }
	
    create_visualization() {
        var table = document.createElement("table");
        var table_body = document.createElement("tbody");
        for (var row = 0; row < this.y_size; row++) {
            var table_row = document.createElement("tr");
            for (var col = 0; col < this.x_size; col++) {
                var table_data = document.createElement('td');
				table_data.id = "r-" + row + "_c-" + col; 
				
                var chip = this.chips.find(function(item) { return item.x === col && item.y === row });
				var connection = this.connections.find(function(item) { return item.intersect_point(col, row) });
				
				// create empty cell
                if (chip === undefined && connection === undefined) {
                    var span = document.createElement("span");
                    span.className = 'empty';
                    table_data.appendChild(span);
                } 
				// create chip cell
				else if (chip !== undefined) {
                    table_data.appendChild(chip.create_visualization());
					table_data.id = "mc_r-" + row + "_c-" + col;
                } 
				// create connection cell
				else {
					table_data.appendChild(connection.create_visualization());
				}
                    
                table_row.appendChild(table_data);
            }
            table_body.appendChild(table_row);
        }
        table.appendChild(table_body);
        return table;
    }

    count_connections(chip) {
        var count = 0;
		this.connections.forEach(function(item) { count += (item.first === chip || item.second === chip) ? item.count : 0 })
        return count;
    }
    
    finished() {
		var ref = this;
		var finished = this.chips.every(function(item) { return item.value === ref.count_connections(item) });
		
		$("p.finished_state").empty();
		var text = finished ? "game finished." : "game not finished";
		$("p.finished_state").text(text);
    }
    
    reset() {
		var ref = this;
		this.connections.forEach(function (item) { ref.remove_connection(item); });
        this.connections = [];
    }   
}

var game = new Game(5, 5);