
class Chip {
    
    constructor(value, x, y, mark_function) {
        this.value = value;
        this.x = x;
        this.y = y;
        this.mark_function = mark_function;
		
        this.marked = false;
		this.visualization = this.create_visualization();
    }
    
	mark() {
		this.marked = true;
		this.visualization.style.backgroundColor = "green";
	}
	
	unmark() {
		this.marked = false;
		this.visualization.style.backgroundColor = "transparent";
	}
	
	create_visualization() {
		var btn = document.createElement("button");
        btn.className = "mc";
        var ref = this;
        btn.onclick = function(){
            ref.mark_function(ref);
        };
        
        var t = document.createElement("span");
        t.className = 'mc-' + this.value;
        btn.appendChild(t);
        return btn;
	}
	
    draw() {
		return this.visualization;
    }
}

class Connection {
    
    constructor(first, second, connection_count) {
        this.first = first;
        this.second = second;
        
        if (first.x === second.x) {
            this.direction = "ve";
            this.x_start = first.x;
            this.x_end = first.x;
            this.y_start = Math.min(first.y, second.y) + 1;
            this.y_end = Math.max(first.y, second.y) - 1;
        } 
        else {
            this.direction = "ho";
            this.x_start = Math.min(first.x, second.x) + 1;
            this.x_end = Math.max(first.x, second.x) - 1;
            this.y_start = first.y;
            this.y_end = first.y;
        }
                
		this.connection_count = connection_count;
    }
	
	intersect_point(x, y) {
		return this.x_start <= x && this.x_end >= x && this.y_start <= y && this.y_end >= y;
	}
	
    between(a, b, c) {
        var eps = 0.0000001;
        return a-eps <= b && b <= c+eps;
    }
	
    intersect_other_connection(other) {
        var x1 = this.x_start;
        var x2 = this.x_end;
        var y1 = this.y_start;
        var y2 = this.y_end;
        
        var x3 = other.x_start;
        var x4 = other.x_end;
        var y3 = other.y_start;
        var y4 = other.y_end;
        
        var x=((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
        var y=((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4));
        if (isNaN(x)||isNaN(y)) {
            return false;
        } else {
            if (x1>=x2) {
            if (!this.between(x2, x, x1)) {return false;}
        } else {
            if (!this.between(x1, x, x2)) {return false;}
        }
        if (y1>=y2) {
            if (!this.between(y2, y, y1)) {return false;}
        } else {
            if (!this.between(y1, y, y2)) {return false;}
        }
        if (x3>=x4) {
            if (!this.between(x4, x, x3)) {return false;}
        } else {
            if (!this.between(x3, x, x4)) {return false;}
        }
        if (y3>=y4) {
            if (!this.between(y4, y, y3)) {return false;}
        } else {
            if (!this.between(y3, y, y4)) {return false;}
        }
        }
        return true;
    }
	
	does_connect(first, second) {
        return (this.first === first && this.second === second) || (this.first === second && this.second == first);
    }
	
	create_visualization() {
		var span = document.createElement("span");
		span.className = "co-" + this.direction + "-" + this.connection_count;
		return span;
	}
}

class Game {
    
    constructor(x_size, y_size) {
        this.x_size = x_size;
        this.y_size = y_size;
        
        this.chips = [];
		this.connections = [];
    }

    init_by_json(json) {
    }
    
	get_marked_chips() {
		var marked_chips = []
		for (var i = 0; i < this.chips.length; i++) {
			var chip = this.chips[i];
			if (chip.marked) {
				marked_chips.push(chip);
			}
		}
		return marked_chips;
	}
	
    init() {
		var ref = this;
        var mark_function = function(chip) {
			var marked_chips = ref.get_marked_chips();
			
			// mark a single chip
			if (marked_chips.length <= 0 || (marked_chips.length == 1 && marked_chips.indexOf(chip) >= 0)) {
				if (chip.marked) {
					chip.unmark();
				} else {
					chip.mark();
				}				
			} else {
				// mark second chip and connect them if possible
				var first_chip = marked_chips[0];
				if (first_chip.x != chip.x && first_chip.y != chip.y) { return; }

                var connection_exists = false;
                var connection = undefined;
                for (var i = 0; i < ref.connections.length; i++) {
                    connection = ref.connections[i];
                    if (connection.does_connect(first_chip, chip)) {
                        connection_exists = true;
                        break;
                    }
                }
				
				if (connection_exists) {
                    if (connection.connection_count === 1) {
                        connection.connection_count = 2;
                        // draw connection	with two lines			
                        for (var i = connection.x_start; i <= connection.x_end; i++) {
                            for (var j = connection.y_start; j <= connection.y_end; j++) {
                                var cell = "r-" + j + "_c-" + i;
                                $( "#" + cell).html(connection.create_visualization());
                                console.log(cell);
                            }
                        }
                        
                        first_chip.unmark();
                    } else {
                        // remove connection 
                        ref.remove_connection(connection);
                        var index = ref.connections.indexOf(connection);
                        if (index > -1) {
                            ref.connections.splice(index, 1);
                        }
        
                        first_chip.unmark();
                    }
                    
                } else {
                    connection = new Connection(first_chip, chip, 1);
                    for (var i = 0; i < ref.connections.length; i++) {		
                        if (connection.intersect_other_connection(ref.connections[i])) {
                            // do not mark because it is not possible
                            return;
                        }
                    }
                
                    // check if it does not intersect with other mc
                    for (var i = 0; i < ref.chips.length; i++) {
                        var other_chip = ref.chips[i];
                        if (other_chip == first_chip || other_chip == chip) {
                            continue;
                        }
                        
                        if (connection.intersect_point(other_chip.x, other_chip.y)) {
                            return;
                        }
                    }
                    
                    // no line intersects with the new one
                    ref.connections.push(connection);
                    
                    // draw connection				
                    for (var i = connection.x_start; i <= connection.x_end; i++) {
                        for (var j = connection.y_start; j <= connection.y_end; j++) {
                            var cell = "r-" + j + "_c-" + i;
                            $( "#" + cell).html(connection.create_visualization());
                            console.log(cell);
                        }
                    }
                    
                    first_chip.unmark();
                }
			}
        };
        
        this.chips[0] = new Chip(2, 0, 0, mark_function);
        this.chips[1] = new Chip(2, 4, 0, mark_function);
        this.chips[2] = new Chip(3, 0, 2, mark_function);

        this.chips[3] = new Chip(5, 2, 2, mark_function);
        this.chips[4] = new Chip(4, 4, 2, mark_function);
        this.chips[5] = new Chip(2, 0, 4, mark_function);
        
        this.chips[6] = new Chip(4, 2, 4, mark_function);
    }

    remove_connection(connection) {
        for (var i = connection.x_start; i <= connection.x_end; i++) {
            for (var j = connection.y_start; j <= connection.y_end; j++) {
                var cell = "r-" + j + "_c-" + i;
                var span = document.createElement("span");
                span.className = 'empty';
                $( "#" + cell).html(span);
            }
        }
    }
    
    get_chip(x, y) {
        for (var i = 0; i < this.chips.length; i++) {
            var chip = this.chips[i];
            if (chip.x === x && chip.y === y) {
                return chip;
            }
        }
        return undefined;
    }
    
	get_connection(x, y) {
		for (var i = 0; i < this.connections.length; i++) {
			var connection = this.connections[i];
			if (connection.intersect_point(x, y)) {
				return connection;
			}
		}
		return undefined;
	}
	
    draw() {
        var table = document.createElement("table");
        var table_body = document.createElement("tbody");
        for (var row = 0; row < this.y_size; row++) {
            var table_row = document.createElement("tr");
            for (var col = 0; col < this.x_size; col++) {
                var table_data = document.createElement('td');
				table_data.id = "r-" + row + "_c-" + col; 
				
                var chip = this.get_chip(col, row);
				var connection = this.get_connection(col, row);
                if (chip === undefined && connection === undefined) {
                    var span = document.createElement("span");
                    span.className = 'empty';
                    table_data.appendChild(span);
                } else if (chip !== undefined) {
                    table_data.appendChild(chip.draw());
					table_data.id = "mc_r-" + row + "_c-" + col;
                } else {
					table_data.appendChild(connection.draw());
				}
                    
                table_row.appendChild(table_data);
            }
            table_body.appendChild(table_row);
        }
        table.appendChild(table_body);
        return table;
    }

    get_connection_count(chip) {
        var count = 0;
        for (var i = 0; i < this.connections.length; i++) {
            var connection = this.connections[i];
            if (connection.first === chip || connection.second === chip) {
                count += connection.connection_count;
            }
        }
        return count;
    }
    
    is_finished() {
        for (var i = 0; i < this.chips.length; i++) {
            var chip = this.chips[i];
            var count = this.get_connection_count(chip);
            if (chip.value !== count) {
                return false;
            }
            
        }
        return true;
    }
    
    reset() {
        for (var i = 0; i < this.connections.length; i++) {
            var connection = this.connections[i];
            this.remove_connection(connection);
        }
        this.connections = [];
    }
    
}

var game = new Game(5, 5);

function init() {
    game.init();
    
    $("div.game").empty();
    var game_gui = $("div.game")[0];
    game_gui.appendChild(game.draw());
}

function check_finished() {
    $("p.finished_state").empty();
    if (game.is_finished()) {
        $("p.finished_state").text("game finished.");
    } else {
        $("p.finished_state").text("game not finished.");
    }
}

function reset_game() {
    game.reset();
}
