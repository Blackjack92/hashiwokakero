
/*!
	Hashiwokakero
	v1
	https://github.com/Blackjack92/hashiwokakero
	Author: Kevin Wallis
	License: MIT
*/

class Chip {
    
    constructor(value, x, y, mark_function) {
        // value is the number of needed connections
        this.value = value;
        // x any are the position of the chip
        this.x = x;
        this.y = y;
        
        // The mark_function is used to handle a click on the chip
        // depending on this a connection is created, deleted or nothing is done (not allowed connection)
        this.mark_function = mark_function;
		
        // A unique identifier
		this.id = x + "_" + y;
        
        // marked is selected for connection
        this.marked = false;
        // highlighted is used for highlighting specific chips (like a flag in minesweeper)
		this.highlighted = false;
    }
	
	/*
     * Toggles the selection of the chip.
     */
	toggle_mark() {
		if (this.marked) {
			this.unmark();
		} else {
			this.mark();
		}
	}
	
	/*
     * Selects the chip.
     */ 
	mark() {
		this.marked = true;
        // Change the color of the chip, when it is selected
		$("#" + this.id).css("background-color", "green");
	}
	
	/*
     * Deselects the chip.
     */
	unmark() {
		this.marked = false;
        // Change the color of the chip, when it is selected
		$("#" + this.id).css("background-color", "transparent");
	}
	
	/*
     * Toggle the flag for the chip.
     */
	toogle_highlight() {
        // It is necessary to unmark the chip before otherwise a flagged chip could be connected.
		this.unmark();
		
		if (this.highlighted) {
			this.unhighlight();
		} else {
			this.highlight();
		}
	}
	
	/*
     * Highlight the chip.
     */
	highlight() {	
		$("#" + this.id).css("background-color", "orange");
		this.highlighted = true;
	}
	
	/*
     * Unhighlight the chip.
     */
	unhighlight() {
		$("#" + this.id).css("background-color", "transparent");
		this.highlighted = false;
	}
	
	/*
     * Remove selection and highlighting, so that the chip is "clean".
     */
	set_default() {
        this.unmark();
        this.unhighlight();
    }
	
	/*
     * Creates the visualization for the chip and returns it.
     */
	create_visualization() {
        // The chip is visualized with a button so that it can be clicked without further code.
		var btn = document.createElement("button");
        btn.className = "mc";
		btn.id = this.id;

        // Attaches the selection function on button click.
        var ref = this;
        btn.onclick = function(){
            ref.mark_function(ref);
        };
		
        // Attaches the highlight function on the right mouse click.
		btn.oncontextmenu = function(ev) {
            // This is necessary otherwise the context menu would open.
			ev.preventDefault();
            
            // Highlight or unhighlight.
			ref.toogle_highlight();
			return false;
		}
        
        // The span holds the image for the chip. This is done with the class attribute.
        var t = document.createElement("span");
        t.className = 'mc-' + this.value;
        btn.appendChild(t);
        return btn;
	}
}

class Connection {
    
    constructor(first, second, count) {
        this.first = first;
        this.second = second;  
        // The number of lines which are used (1-2).
		this.count = count;
		
        // This is used so that x_start, x_end, y_start and y_end are sorted. Otherwise it is 
        // possible that x_end is bigger than x_start.
		this.update_start_end(first, second);
    }
	
	/*
     * Initializes x_start, x_end, y_start and y_end of the connection. 
     */
	update_start_end(first, second) {
		if (first.x === second.x) {
            this.direction = "ve";
            this.x_start = first.x;
            this.x_end = first.x;
            // +1 and -1 so that the chip position itself is not part of the connection
            this.y_start = Math.min(first.y, second.y) + 1;
            this.y_end = Math.max(first.y, second.y) - 1;
        } 
        else {
            this.direction = "ho";
            // +1 and -1 so that the chip position itself is not part of the connection
            this.x_start = Math.min(first.x, second.x) + 1;
            this.x_end = Math.max(first.x, second.x) - 1;
            this.y_start = first.y;
            this.y_end = first.y;
        }
	}
	
	/*
     * This function checks if a specific point (e.g. a chip position) is inside the connection.
     * This is especially usefull for validation purposes. 
     */
	intersect_point(x, y) {
		return this.x_start <= x && this.x_end >= x && this.y_start <= y && this.y_end >= y;
	}
	
	/*
     * Returns all fields (cells) which are part of the connection. E.g. a connection goes from
     * (0,0) to (0,3) than (0,0), (0,1), (0,2) and (0,3) will be returned.
     */
	get_fields() {
		var fields = [];
		for (var i = this.x_start; i <= this.x_end; i++) {
			for (var j = this.y_start; j <= this.y_end; j++) {
				fields.push(i + " " + j);
			}
		}
		return fields;
	}
	
	/*
     * Checks if two different fields (two arrays of cells) intersect each other. This is used for the evaluation of the
     * connection intersection.
     */
	intersect_fields(fields, other_fields) {
		for (var i = 0; i < fields.length; i++) {
			var field = fields[i];
			for (var j = 0; j < other_fields.length; j++) {
				var other_field = other_fields[j];
				if (field === other_field) {
					return true;
				}
			}
		}
		return false;
	}
	
	/*
     * Checks if two connections have a field (cell) in common. 
     */
    intersect_connection(other) {
		var fields = this.get_fields();
		var other_fields = other.get_fields();
		
		return this.intersect_fields(fields, other_fields) || this.intersect_fields(other_fields, fields);
    }
	
	/*
     * Returns true if the connection does connect the given chips. 
     */
	does_connect(first, second) {
        return (this.first === first && this.second === second) || (this.first === second && this.second == first);
    }
	
	/*
     * Creates and returns the visualization of a single connection field (cell).
     */
	create_visualization() {
		var span = document.createElement("span");
        // The class name is used to load the image, which is defined in css.
		span.className = "co-" + this.direction + "-" + this.count;
		return span;
	}
}

class Game {
    
    constructor() {      
        this.x_size = 0;
        this.y_size = 0;
        
        // Contains the chips and connections, which are currenty part of the game.
        this.chips = [];
		this.connections = [];
    }
	
	/*
     * This function is responsible to mark (select) a chip. Furthermore, this function has different 
     * objectives:
     * - if it is the first chip, which is selected for connection, then it will mark the chip
     * - if the second chip is selected a connection will be created (first it validate if it is possible, intersect, etc.)
     * - if a connection is created a second time, it will add a second line to the existing connection
     * - if a connection is created a third time, it will remove the existing connection
     */
	marking (chip) {
		var marked_chips = this.chips.filter(function (item) { return item.marked });
		
		// Mark a single chip.
		if (marked_chips.length <= 0 || (marked_chips.length == 1 && marked_chips.indexOf(chip) >= 0)) {
			chip.toggle_mark();			
		} else {
			// Mark second chip and connect them if possible.
			var first = marked_chips[0];
			
			// Check if they are horizontal or vertical the same.
			if (first.x != chip.x && first.y != chip.y) { return; }

			// check if the connection already exists, three possiblities:
			// - does not exist: create new connection
			// - single connection does exist: add second connection
			// - double connection does exist: remove connection
			var connection = this.connections.find(function(item) { return item.does_connect(first, chip) });
			
			if (connection !== undefined) {
				// Single connection exist: add second connection.
				if (connection.count === 1) {
					connection.count += 1;
					this.draw_connection(connection);                        
				} 
				// Double connection exist: remove connection.
				else {
					this.remove_connection(connection);
					var index = this.connections.indexOf(connection);
					if (index > -1) { this.connections.splice(index, 1); }
				}
				first.unmark();
				
			} else {
				// Create new connection.
				connection = new Connection(first, chip, 1);
				
				// Check connection intersects with another connection.
				var intersect = this.connections.some(function(item) { return connection.intersect_connection(item) });
				if (intersect) { return; }
			
				// Check connections intersects with another chip.
				intersect = this.chips.some(function(item) { return item !== first && item !== chip && connection.intersect_point(item.x, item.y) });
				if (intersect) { return; }
				
				// Connection does not intersect, so add it.
				this.connections.push(connection);
				this.draw_connection(connection);
				first.unmark();
			}
		}
	}
	
    /*
     * Initializes a default game, which is the same as the code competition example.
     */
    init() {
		var ref = this;
        
        // Attach mark_function to every created chip.
        var mark_function = function(chip) { return ref.marking(chip) };
			        
		// Default game.
        this.chips[0] = new Chip(2, 0, 0, mark_function);
        this.chips[1] = new Chip(2, 4, 0, mark_function);
        this.chips[2] = new Chip(3, 0, 2, mark_function);
        this.chips[3] = new Chip(5, 2, 2, mark_function);
        this.chips[4] = new Chip(4, 4, 2, mark_function);
        this.chips[5] = new Chip(2, 0, 4, mark_function);
        this.chips[6] = new Chip(4, 2, 4, mark_function);

        this.x_size = 5;
        this.y_size = 5;
        
        // Update the gui after the game was initialized.
        this.update_gui();
    }

    /*
     * Updates the gui depending on the current game state. This is used, when a new game is initialized.
     */
    update_gui() {
        $("div.game").empty();
		var game_gui = $("div.game")[0];
		game_gui.appendChild(this.create_visualization());
    }
    
    /*
     * Draws a connection to the given x_start, x_end, y_start and y_end inside a table.
     */
	draw_connection(connection) {
		 for (var i = connection.x_start; i <= connection.x_end; i++) {
			for (var j = connection.y_start; j <= connection.y_end; j++) {
				var cell = "r-" + j + "_c-" + i;
				$( "#" + cell).html(connection.create_visualization());
			}
		}
	}
	
	/*
     * Replaces the connection visualization with empty spans.
     */
    remove_connection(connection) {
        for (var i = connection.x_start; i <= connection.x_end; i++) {
            for (var j = connection.y_start; j <= connection.y_end; j++) {
                var cell = "r-" + j + "_c-" + i;
                var span = document.createElement("span");
                span.className = 'empty';
                $( "#" + cell).html(span);
            }
        }
    }
	
	/*
     * Creates the game after the chips and connections have been initialized.
     */
    create_visualization() {
        var table = document.createElement("table");
        // This sets the ui width and height, so that it does not change on different screen resolutions.
        table.style.width = (this.x_size*64) + "px";
        table.style.height = (this.y_size*64) + "px";
        
        // Create the game by using a table.
        var table_body = document.createElement("tbody");
        for (var row = 0; row < this.y_size; row++) {
            var table_row = document.createElement("tr");
            for (var col = 0; col < this.x_size; col++) {
                var table_data = document.createElement('td');
				table_data.id = "r-" + row + "_c-" + col; 
				
                // Get chip or connection for a specific table cell.
                var chip = this.chips.find(function(item) { return item.x === col && item.y === row });
				var connection = this.connections.find(function(item) { return item.intersect_point(col, row) });
				
				// Create a empty cell, if nothing is positioned on the given cell.
                if (chip === undefined && connection === undefined) {
                    var span = document.createElement("span");
                    span.className = 'empty';
                    table_data.appendChild(span);
                } 
				// Create a chip cell.
				else if (chip !== undefined) {
                    table_data.appendChild(chip.create_visualization());
					table_data.id = "mc_r-" + row + "_c-" + col;
                } 
				// Create a connection cell.
				else {
					table_data.appendChild(connection.create_visualization());
				}
                    
                table_row.appendChild(table_data);
            }
            table_body.appendChild(table_row);
        }
        table.appendChild(table_body);
        return table;
    }

    /*
     * Returns the connections of a given chip. This function is used to check if the game is finished.
     */
    count_connections(chip) {
        var count = 0;
		this.connections.forEach(function(item) { count += (item.first === chip || item.second === chip) ? item.count : 0 })
        return count;
    }
    
    /*
     * Checks if the game is finished and sets depending on the game state the output message.
     */
    finished() {
		var ref = this;
		var finished = this.chips.every(function(item) { return item.value === ref.count_connections(item) });
		
        // Set the current game state: finished or not finished.
		$("p.finished_state").empty();
		var text = finished ? "game finished." : "game not finished";
		$("p.finished_state").text(text);
    }
    
    /*
     * Resets the whole game, so that it starts by zero.
     */
    reset() {
		var ref = this;
		this.connections.forEach(function (item) { ref.remove_connection(item); });
        this.connections = [];
        // Reset the selection and highlight state of the chips.
        this.chips.forEach(function (item) { item.set_default(); });
    }   
    
    /*
     * Highlights all chips, which do not have the expected number of connections.
     */
    highlight() {
        // Unhighlight all, otherwise it is possible that more then the wrong chips are highlighted.
        this.unhighlight();
        
        var ref = this;
        this.chips.forEach(function(item) { 
            if (item.value !== ref.count_connections(item)) {
                item.highlight();
            }
        });
    }
    
    /*
     * Unhighlights all chips.
     */
    unhighlight() {
        this.chips.forEach(function(item) { item.unhighlight(); });
    }
    
    /*
     * This function displays the modal load dialog. In the modal dialog a structured hashiwokakero game can be loaded. 
     */
    display_load() {
        // Get the modal.
        var modal = document.getElementById('modal_load');
        modal.style.display = "block";

        // Get the <span> element that closes the modal.
        var span = document.getElementById("close_load");

        // Set an example hashiwokakero game, to see the expected structure.
        var textarea = document.getElementsByClassName("example")[0];
        textarea.value = "3 - 4 - - 2 - 2 - 2 - - 2\n\
- - - - 3 H 3 - 2 - - 2 -\n\
- - - - - - - 1 - - 2 - -\n\
1 - 5 - 7 - 6 - - 1 - - 2\n\
v - V - v - - 1 - - 3 - -\n\
1 - 6 - 4 h 7 - - 3 - - 1\n\
- - - - - - - - 1 - - 1 -\n\
2 - 6 - 6 - 6 - - - 5 - 2\n\
- 1 - - - - - - - 1 - - -\n\
2 - - - 4 - 7 - 4 - 4 - 2\n\
- - 1 - - - - - - - - - -\n\
- 2 - - 3 - 5 - 4 - - 1 -\n\
2 - - 2 - 2 - 2 - - 2 - 2\n\
\n\
v ... is a single vertical connection\n\
V ... is a double vertical connection\n\
h ... is a single horizontal connection\n\
H ... is a double horizontal connection";
        
        // When the user clicks on <span> (x), close the modal.
        span.onclick = function() {
            modal.style.display = "none";
        }

        // When the user clicks anywhere outside of the modal, close it.
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }
    }
    
    /*
     * This function displays a modal dialog for the export of the current game. 
     */
    display_export() {
        // Get the modal.
        var modal = document.getElementById('modal_export');
        modal.style.display = "block";

        // Get the <span> element that closes the modal.
        var span = document.getElementById("close_export");
        
        // When the user clicks on <span> (x), close the modal.
        span.onclick = function() {
            modal.style.display = "none";
        }

        // When the user clicks anywhere outside of the modal, close it.
        window.onclick = function(event) {
            if (event.target == modal) {
                modal.style.display = "none";
            }
        }
        
        // Set the value of the export textarea to the current game value.
        var textarea = document.getElementsByClassName("export_game")[0];
        textarea.value = this.export_to_csv();
    }
    
    /*
     * This function creates the respresentation for the export. The result of this could 
     * be copied and passed into the import functionality.
     */
    export_to_csv() {
        // The result is stored in the csv variable.
        var csv = "";
        for (var row = 0; row < this.y_size; row++) {
            var csv_row = "";
            for (var col = 0; col < this.x_size; col++) {
                
                // Try to get the chip or the connection for a given position.
                var chip = this.chips.find(function(item) { return item.x === col && item.y === row });
				var connection = this.connections.find(function(item) { return item.intersect_point(col, row) });
				
				// Create empty cell.
                if (chip === undefined && connection === undefined) {
                    csv_row += "- ";
                } 
				// Create chip cell.
				else if (chip !== undefined) {
                    csv_row += chip.value + " ";
                } 
				// Create connection cell.
				else {
                    // It is necessary to use upper and lower case to differenciate between single and double connections.
                    if (connection.direction === "ho") {
                        csv_row += connection.count === 1 ? "h " : "H ";
                    } else {
                        csv_row += connection.count === 1 ? "v " : "V ";
                    }
				}
            }
            
            csv += csv_row.trim() + "\n";
        }
        // Remove the \n at the end of the result.
        return csv.replace(/^\s+|\s+$/g, '');
    }
    
    /*
     * This method loads an existing hashiwokakero game, which is entered into a textarea. 
     */
    load_from_csv() {
        var textarea = document.getElementsByClassName("load-game")[0];
        var ref = this;
        
        // parse the given hashiwokakero game input string.
        Papa.parse(textarea.value, { delimiter: ' ',
            error: function(err, file, inputElem, reason)
            {
                alert("Parsing was not successfull.");
            },
            complete: function(data, file)
            {
                var mark_function = function(chip) { return ref.marking(chip) };
                
                // First add all chips the game. If it is not successfull e.g. because it does contain
                // invalid characters, the import process stops.
                var successfull = true;
                // Temp chips are used to store the read chips. Only if the whole import process was 
                // successfull the chips will be used as game chips.
                var temp_chips = [];
                for (var row = 0; row < data.data.length; row++) {
                    for (var col = 0; col < data.data[row].length; col++) {
                        var entry = data.data[row][col];
                        
                        if (entry === '-' || entry.toLowerCase() == 'h' || entry.toLowerCase() == 'v') {
                            continue;
                        }
                        
                        var value = parseInt(entry);
                        // Check if the parse task was successfull otherwise the import does not work.
                        if (isNaN(value) || value < 1 || value > 8) {
                            successfull = false;
                            break;
                        }
                        
                        temp_chips.push(new Chip(value, col, row, mark_function));
                    }
                }
                
                if (!successfull) {
                    alert("Parsing of the chips, was not successfull.");
                    return;
                }
                
                // Here the connections are created. Also a temp connection variable is used, so that only 
                // a successfull import process is loaded into the game.
                var temp_connections = []
                for (var row = 0; row < data.data.length; row++) {
                    for (var col = 0; col < data.data[row].length; col++) {
                        var entry = data.data[row][col];
                        if (!(entry.toLowerCase() == 'h' || entry.toLowerCase() === 'v')) {
                            continue;
                        }

                        // Check if the current cell interesects an existing connection.
                        intersect = temp_connections.some(function(item) { return item.intersect_point(col, row) });
                        if (intersect) { continue; }                      

                        var first = undefined;
                        var second = undefined;
                        var symbol = entry;
                        
                        if (symbol === 'h' || symbol === 'H') {
                            // Search for horizontal connections.
                            var index = col;
                            while (index < data.data[row].length && entry === symbol) {
                                entry = data.data[row][index];
                                index++;
                            }
                            
                            first = temp_chips.find(function(item) { return item.x === (col - 1) && item.y === row });                        
                            second = temp_chips.find(function(item) { return item.x === (index - 1) && item.y === row });    
                        } 
                        else if (symbol === 'v' || symbol === 'V')  {
                            // Search for vertical connections.
                            var index = row;
                            while (index < data.data.length && entry === symbol) {
                                entry = data.data[index][col];
                                index++;
                            }
                            
                            first = temp_chips.find(function(item) { return item.x === col && item.y === (row - 1) });                        
                            second = temp_chips.find(function(item) { return item.x === col && item.y === (index - 1) });
                        }
                        
                        if (first === undefined || second === undefined) {
                            alert("Parsing of the connections, was not successfull.");
                            return;
                        }
                        
                        // On success create new connection.
                        var type = symbol == symbol.toLowerCase() ? 1 : 2;
                        var connection = new Connection(first, second, type);
				
                        // Check connection intersects with another connection.
                        var intersect = temp_connections.some(function(item) { return connection.intersect_connection(item) });
                        if (intersect) { 
                            successfull = false;
                            break; 
                        }
                        
                        // Connection does not intersect, so add it.
                        temp_connections.push(connection);
                    }
                }
                
                if (!successfull) {
                    alert("Parsing of the connections, was not successfull.");
                    return;
                }
                
                // Update the gui after a new game is loaded.
                ref.reset();
                ref.connections = temp_connections;
                ref.chips = temp_chips;
                ref.x_size = data.data[0].length;
                ref.y_size = data.data.length;
                ref.update_gui();
                
                // Close the modal load dialog.
                var modal = document.getElementById('modal_load');
                modal.style.display = "none";
            } } 
        );
    }
}

var game = new Game();
